diff --git ext/pdo_pgsql/pgsql_driver.c ext/pdo_pgsql/pgsql_driver.c
index 11fa58b4a7b..eb3ac329785 100644
--- ext/pdo_pgsql/pgsql_driver.c
+++ ext/pdo_pgsql/pgsql_driver.c
@@ -35,6 +35,7 @@
 #include "pgsql_driver_arginfo.h"
 
 static bool pgsql_handle_in_transaction(pdo_dbh_t *dbh);
+void pgsql_stmt_finish(pdo_pgsql_stmt *S, int fin_mode);
 
 static char * _pdo_pgsql_trim_message(const char *message, int persistent)
 {
@@ -103,6 +121,13 @@ int _pdo_pgsql_error(pdo_dbh_t *dbh, pdo_stmt_t *stmt, int errcode, const char *
 }
 /* }}} */
 
+static zend_always_inline void pgsql_finish_running_stmt(pdo_pgsql_db_handle *H)
+{
+	if (H->running_stmt && H->running_stmt->is_running_unbuffered) {
+		pgsql_stmt_finish(H->running_stmt, 0);
+	}
+}
+
 static void _pdo_pgsql_notice(void *context, const char *message) /* {{{ */
 {
 	int ret;
@@ -260,6 +260,9 @@
 			PQfinish(H->server);
 			H->server = NULL;
 		}
+		if (H->cached_table_name) {
+			efree(H->cached_table_name);
+		}
 		if (H->einfo.errmsg) {
 			pefree(H->einfo.errmsg, dbh->is_persistent);
 			H->einfo.errmsg = NULL;
@@ -252,6 +252,9 @@ static void pgsql_handle_closer(pdo_dbh_t *dbh) /* {{{ */
 			PQfinish(H->server);
 			H->server = NULL;
 		}
+		if (H->cached_table_name) {
+			efree(H->cached_table_name);
+		}
 		if (H->einfo.errmsg) {
 			pefree(H->einfo.errmsg, dbh->is_persistent);
 			H->einfo.errmsg = NULL;
@@ -348,6 +375,7 @@ static zend_long pgsql_handle_doer(pdo_dbh_t *dbh, const zend_string *sql)
 
 	bool in_trans = pgsql_handle_in_transaction(dbh);
 
+	pgsql_finish_running_stmt(H);
 	if (!(res = PQexec(H->server, ZSTR_VAL(sql)))) {
 		/* fatal error */
 		pdo_pgsql_error(dbh, PGRES_FATAL_ERROR, NULL);
@@ -415,6 +443,7 @@ static zend_string *pdo_pgsql_last_insert_id(pdo_dbh_t *dbh, const zend_string *
 	PGresult *res;
 	ExecStatusType status;
 
+	pgsql_finish_running_stmt(H);
 	if (name == NULL) {
 		res = PQexec(H->server, "SELECT LASTVAL()");
 	} else {
@@ -578,6 +607,7 @@ static bool pdo_pgsql_transaction_cmd(const char *cmd, pdo_dbh_t *dbh)
 	PGresult *res;
 	bool ret = true;
 
+	pgsql_finish_running_stmt(H);
 	res = PQexec(H->server, cmd);
 
 	if (PQresultStatus(res) != PGRES_COMMAND_OK) {
@@ -686,6 +716,7 @@ void pgsqlCopyFromArray_internal(INTERNAL_FUNCTION_PARAMETERS)
 	while ((pgsql_result = PQgetResult(H->server))) {
 		PQclear(pgsql_result);
 	}
+	pgsql_finish_running_stmt(H); /* Maybe in the future combine with the getResult loop in a pgsql_consume_running_stmt */
 	pgsql_result = PQexec(H->server, query);
 
 	efree(query);
@@ -810,6 +841,7 @@ void pgsqlCopyFromFile_internal(INTERNAL_FUNCTION_PARAMETERS)
 	while ((pgsql_result = PQgetResult(H->server))) {
 		PQclear(pgsql_result);
 	}
+	pgsql_finish_running_stmt(H); /* Maybe in the future combine with the getResult loop in a pgsql_consume_running_stmt */
 	pgsql_result = PQexec(H->server, query);
 
 	efree(query);
@@ -906,6 +938,7 @@ void pgsqlCopyToFile_internal(INTERNAL_FUNCTION_PARAMETERS)
 	while ((pgsql_result = PQgetResult(H->server))) {
 		PQclear(pgsql_result);
 	}
+	pgsql_finish_running_stmt(H); /* Maybe in the future combine with the getResult loop in a pgsql_consume_running_stmt */
 
 	/* using pre-9.0 syntax as PDO_pgsql is 7.4+ compatible */
 	if (pg_fields) {
@@ -997,6 +1030,7 @@ void pgsqlCopyToArray_internal(INTERNAL_FUNCTION_PARAMETERS)
 	while ((pgsql_result = PQgetResult(H->server))) {
 		PQclear(pgsql_result);
 	}
+	pgsql_finish_running_stmt(H); /* Maybe in the future combine with the getResult loop in a pgsql_consume_running_stmt */
 
 	/* using pre-9.0 syntax as PDO_pgsql is 7.4+ compatible */
 	if (pg_fields) {
@@ -1424,6 +1448,7 @@ static int pdo_pgsql_handle_factory(pdo_dbh_t *dbh, zval *driver_options) /* {{{
 
 	H->attached = 1;
 	H->pgoid = -1;
+	H->cached_table_oid = InvalidOid;
 
 	dbh->methods = &pgsql_methods;
 	dbh->alloc_own_columns = 1;
diff --git ext/pdo_pgsql/pgsql_statement.c ext/pdo_pgsql/pgsql_statement.c
index 8f3dd5237b5..53e7c08f1e0 100644
--- ext/pdo_pgsql/pgsql_statement.c
+++ ext/pdo_pgsql/pgsql_statement.c
@@ -56,7 +56,7 @@
 
 
 
-static void pgsql_stmt_finish(pdo_pgsql_stmt *S, int fin_mode)
+void pgsql_stmt_finish(pdo_pgsql_stmt *S, int fin_mode)
 {
 	pdo_pgsql_db_handle *H = S->H;
 
@@ -88,9 +111,9 @@ static int pgsql_stmt_dtor(pdo_stmt_t *stmt)
 		}
 
 		S->is_prepared = false;
-		if (H->running_stmt == S) {
+	}
+	if (H->running_stmt == S && (fin_mode & (FIN_CLOSE|FIN_ABORT))) {
 			H->running_stmt = NULL;
-		}
 	}
 }
 
@@ -585,12 +702,29 @@ static int pgsql_stmt_get_col(pdo_stmt_t *stmt, int colno, zval *result, enum pd
 	return 1;
 }
 
-static zend_always_inline char * pdo_pgsql_translate_oid_to_table(Oid oid, PGconn *conn)
+static zend_always_inline char * pdo_pgsql_translate_oid_to_table(Oid oid, pdo_pgsql_db_handle *H)
 {
+	PGconn *conn = H->server;
 	char *table_name = NULL;
 	PGresult *tmp_res;
 	char *querystr = NULL;
 
+	if (oid == H->cached_table_oid) {
+		return H->cached_table_name;
+	}
+
+	if (H->running_stmt && H->running_stmt->is_unbuffered) {
+		/* in single-row mode, libpq forbids passing a new query
+		 * while we're still flushing the current one's result */
+		return NULL;
+	}
+
+	if (H->cached_table_name) {
+		efree(H->cached_table_name);
+		H->cached_table_name = NULL;
+		H->cached_table_oid = InvalidOid;
+	}
+
 	spprintf(&querystr, 0, "SELECT RELNAME FROM PG_CLASS WHERE OID=%d", oid);
 
 	if ((tmp_res = PQexec(conn, querystr)) == NULL || PQresultStatus(tmp_res) != PGRES_TUPLES_OK) {
@@ -607,6 +740,8 @@ static zend_always_inline char * pdo_pgsql_translate_oid_to_table(Oid oid, PGcon
 		return 0;
 	}
 
+	H->cached_table_oid = oid;
+	H->cached_table_name = estrdup(table_name);
 	table_name = estrdup(table_name);
 
 	PQclear(tmp_res);
@@ -635,10 +770,9 @@ static int pgsql_stmt_get_column_meta(pdo_stmt_t *stmt, zend_long colno, zval *r
 
 	table_oid = PQftable(S->result, colno);
 	add_assoc_long(return_value, "pgsql:table_oid", table_oid);
-	table_name = pdo_pgsql_translate_oid_to_table(table_oid, S->H->server);
+	table_name = pdo_pgsql_translate_oid_to_table(table_oid, S->H);
 	if (table_name) {
-		add_assoc_string(return_value, "table", table_name);
-		efree(table_name);
+		add_assoc_string(return_value, "table", S->H->cached_table_name);
 	}
 
 	switch (S->cols[colno].pgsql_type) {
@@ -677,6 +811,10 @@ static int pgsql_stmt_get_column_meta(pdo_stmt_t *stmt, zend_long colno, zval *r
 			break;
 		default:
 			/* Fetch metadata from Postgres system catalogue */
+			if (S->H->running_stmt && S->H->running_stmt->is_unbuffered) {
+				/* libpq forbids calling a query while we're still reading the preceding one's */
+				break;
+			}
 			spprintf(&q, 0, "SELECT TYPNAME FROM PG_TYPE WHERE OID=%u", S->cols[colno].pgsql_type);
 			res = PQexec(S->H->server, q);
 			efree(q);
diff --git ext/pdo_pgsql/php_pdo_pgsql_int.h ext/pdo_pgsql/php_pdo_pgsql_int.h
index fc9f1664cc3..bba92098261 100644
--- ext/pdo_pgsql/php_pdo_pgsql_int.h
+++ ext/pdo_pgsql/php_pdo_pgsql_int.h
@@ -41,6 +43,8 @@ typedef struct {
 	unsigned 	_reserved:31;
 	pdo_pgsql_error_info	einfo;
 	Oid 		pgoid;
+	Oid cached_table_oid;
+	char *cached_table_name;
 	unsigned int	stmt_counter;
 	/* The following two variables have the same purpose. Unfortunately we need
 	   to keep track of two different attributes having the same effect. */
